# 面试官：说说你了解几种限流算法，手写个demo?

在高并发以及分布式的场景下，接口限流是保护系统稳定性的核心手段。当瞬时流量激增时，合理的限流策略可以避免服务器过载、数据库雪崩等问题。本文将深入解析6种主流限流算法，并提供具体的实现思路，同时也会提供分布式限流的一些思路。
# 一、接口限流
## 1.1 接口限流的必要性
核心作用：防止突发流量导致系统雪崩，保障核心业务可用性。典型应用场景：

- 秒杀活动的库存查询接口
- 第三方API调用频率限制
- 敏感操作防重放攻击

另外也可以防止恶意爬虫以及恶意攻击
## 1.2 什么是限流
限流是对某一时间窗口内的请求数进行限制，保持系统的可用性和稳定性，防止因流量暴增而导致的系统运行缓慢或宕机。

在高并发系统中，出于系统保护角度考虑，通常会对流量进行限流。

在分布式系统中，高并发场景下，为了防止系统因突然的流量激增而导致的崩溃，同时保证服务的高可用性和稳定性，限流是最常用的手段。

# 二、接口限流算法
## 2.1 固定窗口算法
固定窗口算法又称计数器算法、Fixed Window算法，是最简单的限流算法。
### 2.1.1 原理
其原理如下，在指定的固定时间窗口内统计请求次数，超过阈值则拒绝请求。当进入下一个时间周期时进行访问次数的清零。如图所示，我们要求3秒内的请求不要超过150次：
![image](https://github.com/user-attachments/assets/d75a342f-020b-4f40-83e1-80585cc61029)
### 2.1.2 代码实现
最常用的实现就是使用计数器的方式实现                      
以下是单机版版Java代码实现
```java
public class FixedWindowRateLimiter {
    private final long windowSize = 3000; //时间窗口大小，单位毫秒
    private final int maxRequestCount = 150; // 允许通过的请求数
    private final AtomicInteger counter = new AtomicInteger(0); // 当前窗口通过的请求数，AtomicInteger保证线程安全
    private volatile long windowBorder;//窗口右边界

    public boolean tryAcquire() {
        long currentTime = System.currentTimeMillis();
        if (currentTime > windowBorder) { //如果当前时间大于时间窗口的右边界,就一直将窗口的右边界平移
            synchronized (this) { //加锁保证只有一个线程对时间窗口计算，并根据volatile的可见性将windowBorder对其他线程可见
                long now = System.currentTimeMillis(); // 双重检查，避免线程阻塞时currentTime变化产生的影响
                do {
                    windowBorder += windowSize;
                    counter.set(0); // 重置计数器
                } while (now > windowBorder);
            }
        }
        return counter.incrementAndGet() <= maxRequestCount; //判断当前窗口期内的请求数量是否超出限制并对请求数+1
    }
}
```
计数器法，非常简单粗暴，以上demo只是单机式限流。下面说一下分布式情况下的思路
### 2.1.3 具体实现的工具类
### 2.1.4 优缺点
优点：
- 实现简单，容易理解

缺点：
- 限流不够平滑。例如：限流是每秒3个，在第一毫秒发送了3个请求，达到限流，窗口剩余时间的请求都将会被拒绝，体验不好，这种现象叫做“突刺现象”。
- 
- 因为是在某个时间窗口内进行流量控制，所以可能会出现窗口边界效应，即在时间窗口的边界处可能会有大量的请求被允许通过，从而导致突发流量。即：如果第2到3秒内产生了150次请求，而第3到4秒内产生了150次请求，那么其实在第2秒到第4秒这两秒内，就已经发生了300次请求了，远远大于我们要求的3秒内的请求不要超过150次这个限制，如下图所示

![image](https://github.com/user-attachments/assets/6a5a8791-4929-41c8-9247-27de909491f7)

## 2.2 滑动窗口算法
滑动窗口法可以解决固定窗口法下在窗口切换时会受到两倍于阈值数量的请求的问题。

在滑动窗口算法中，窗口的起止时间是动态的，窗口的大小固定。这种算法能够较好地处理窗口边界问题，但是实现相对复杂，需要记录每个请求的时间戳。
### 实现原理
滑动窗口在固定窗口的基础上，将一个窗口分为若干个等份的小窗口，每次仅滑动一小块的时间。每个小窗口对应不同的时间点，拥有独立的计数器，当请求的时间点大于当前窗口的最大时间点时，则将窗口向前平移一个小窗口（将第一个小窗口的数据舍弃，第二个小窗口变成第一个小窗口，当前请求放在最后一个小窗口），整个窗口的所有请求数相加不能大于阈值。其中，Sentinel就是采用滑动窗口算法来实现限流的。如图所示：

![image](https://github.com/user-attachments/assets/8238d78e-97c5-4150-90cc-539b6f5924f3)

核心步骤：
1. 把3秒钟划分为3个小窗，每个小窗限制请求不能超过50秒。
2. 比如我们设置，3秒内不能超过150个请求，那么这个窗口就可以容纳3个小窗，并且随着时间推移，往前滑动。每次请求过来后，都要统计滑动窗口内所有小窗的请求总量。
### 代码实现
### 具体实现的工具类
### 优缺点
## 2.3 漏桶算法
### 实现原理
![image](https://github.com/user-attachments/assets/92c4e367-db48-4c50-991c-4f2a729882fc)
### 代码实现
### 具体实现的工具类
### 优缺点
## 2.4 令牌桶算法
### 实现原理
![image](https://github.com/user-attachments/assets/92c4e367-db48-4c50-991c-4f2a729882fc)
### 代码实现
### 具体实现的工具类
### 优缺点
# 不同限流方法的对比

# 总结
以上就是常见的四种限流方法，但是在实践中，接口的限流不指局限于部署的应用，同样的我们也会使用到例如通过nginx来进行一个接入层的限流，和一个分布式的限流，这些限流的思想大致也都是上述的四种方法。通过合理选择限流算法，可以在保障系统稳定性的同时最大化资源利用率。建议结合具体业务场景进行组合使用，例如网关层使用滑动窗口算法，核心服务采用令牌桶+自适应限流策略
